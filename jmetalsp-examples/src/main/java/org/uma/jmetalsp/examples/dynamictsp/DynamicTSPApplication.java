package org.uma.jmetalsp.examples.dynamictsp;import org.uma.jmetal.operator.CrossoverOperator;import org.uma.jmetal.operator.MutationOperator;import org.uma.jmetal.operator.SelectionOperator;import org.uma.jmetal.operator.impl.crossover.PMXCrossover;import org.uma.jmetal.operator.impl.mutation.PermutationSwapMutation;import org.uma.jmetal.operator.impl.selection.BinaryTournamentSelection;import org.uma.jmetal.solution.PermutationSolution;import org.uma.jmetal.util.comparator.RankingAndCrowdingDistanceComparator;import org.uma.jmetalsp.DataConsumer;import org.uma.jmetalsp.DynamicAlgorithm;import org.uma.jmetalsp.DynamicProblem;import org.uma.jmetalsp.JMetalSPApplication;import org.uma.jmetalsp.algorithm.nsgaii.DynamicNSGAIIBuilder;import org.uma.jmetalsp.consumer.ChartConsumer;import org.uma.jmetalsp.consumer.LocalDirectoryOutputConsumer;import org.uma.jmetalsp.impl.DefaultRuntime;import org.uma.jmetalsp.observeddata.AlgorithmObservedData;import org.uma.jmetalsp.observeddata.ObservedValue;import org.uma.jmetalsp.observer.impl.DefaultObservable;import org.uma.jmetalsp.problem.tsp.MultiobjectiveTSPBuilderFromNYData;import org.uma.jmetalsp.problem.tsp.MultiobjectiveTSPBuilderFromTSPLIBFiles;import org.uma.jmetalsp.problem.tsp.TSPMatrixData;import java.io.IOException;import java.util.List;/** * Example of SparkSP application. * Features: * - Algorithm: to choose among NSGA-II and MOCell * - Problem: Bi-objective TSP * - Default streaming runtime (Spark is not used) * * @author Antonio J. Nebro <antonio@lcc.uma.es> */public class DynamicTSPApplication {  public static void main(String[] args) throws IOException, InterruptedException {    // STEP 1. Create the problem    DynamicProblem<PermutationSolution<Integer>, ObservedValue<TSPMatrixData>> problem;    problem = new MultiobjectiveTSPBuilderFromTSPLIBFiles("data/kroA100.tsp", "data/kroB100.tsp")            .build();    //problem = new MultiobjectiveTSPBuilderFromNYData("data/nyData.txt").build() ;    // STEP 2. Create the algorithm    CrossoverOperator<PermutationSolution<Integer>> crossover;    MutationOperator<PermutationSolution<Integer>> mutation;    SelectionOperator<List<PermutationSolution<Integer>>, PermutationSolution<Integer>> selection;    crossover = new PMXCrossover(0.9);    double mutationProbability = 0.2;    mutation = new PermutationSwapMutation<Integer>(mutationProbability);    selection = new BinaryTournamentSelection<>(            new RankingAndCrowdingDistanceComparator<PermutationSolution<Integer>>());    DynamicAlgorithm<List<PermutationSolution<Integer>>, AlgorithmObservedData> algorithm;    algorithm = new DynamicNSGAIIBuilder<>(crossover, mutation, new DefaultObservable<>())            .setMaxEvaluations(25000)            .setPopulationSize(100)            .setSelectionOperator(selection)            .build(problem);    // STEP 3. Create the streaming data source and register the problem    StreamingTSPSource streamingTSPSource = new StreamingTSPSource(new DefaultObservable<>(), 2000);    // STEP 4. Create the data consumers and register into the algorithm    DataConsumer<AlgorithmObservedData> localDirectoryOutputConsumer =            new LocalDirectoryOutputConsumer<PermutationSolution<Integer>>("outputdirectory");    DataConsumer<AlgorithmObservedData> chartConsumer =            new ChartConsumer<PermutationSolution<Integer>>(algorithm.getName());    // STEP 5. Create the application and run    JMetalSPApplication<            PermutationSolution<Integer>,            DynamicProblem<PermutationSolution<Integer>, ObservedValue<TSPMatrixData>>,            DynamicAlgorithm<List<PermutationSolution<Integer>>, AlgorithmObservedData>> application;    application = new JMetalSPApplication<>();    application.setStreamingRuntime(new DefaultRuntime())            .setProblem(problem)            .setAlgorithm(algorithm)            .addStreamingDataSource(streamingTSPSource,problem)            .addAlgorithmDataConsumer(localDirectoryOutputConsumer)            .addAlgorithmDataConsumer(chartConsumer)            .run();  }}