package org.uma.jmetalsp.externalsources;

import org.uma.jmetalsp.externalsources.lib.GoogleDecode;
import org.uma.jmetalsp.externalsources.lib.ParsedNode;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.uma.jmetalsp.externalsources.lib.Coord;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.w3c.dom.Element;

/**
 * This class parses the new XML Format of the New York Traffic Cameras.
 * 
 * Usages:
 * 
 * * NYTrafficProvider <initial output file> <updates output folder> <[distances file]>
 * 
 *    This is the main usage of the class. It will parse the URL with information about
 *    the New York Traffic Cameras, generating an initial file to execute the problem.
 *    In addition, every 30 seconds a new file will be generated in the updates path,
 *    containing all the speed and time updates since the last iteration:
 * 
 *    - <initial output file>: The file to write the initial problem, containing 
 *      all the initial information to execute the optimization.
 *    - <updates output folder>: The path to generate the updates, where every 30 seconds 
 *      a new file will be written with all the updates received by the traffic cameras.
 *    - <[distances file]>: An optional argument to load the distances between nodes and
 *        avoid doing requests to the Google Service, which has a limited quota.
 * 
 * * NYTrafficProvider -distances <distances output file>
 * 
 *    This is an optional feature to avoid reaching the limit of the Google Services quota.
 *    As the distances never change, it is possible to preload all of them in a file and
 *    pass the generated file to the problem generator.
 *    To load the node distances the program will use the Google Distance Service. You need a 
 *    Google API Key to be able to use the service.
 * 
 *    - <distances output file>: The file to write the distances.
 * 
 * * NYTrafficProvider -output <solution string>
 * 
 *    The last usage is just to generate a file containing all the coordinates of a solution
 *    given by the optimization algorithm. So the solution could be easily shown in a map
 *    or a chart.
 * 
 *    - <solution string>: The solution string generated by the optimization algorithm. It 
 *      contains a list of the nodes forming the solution.
 *      
 * @author Jose Andres Cordero Benitez
 */
public class NYTrafficProvider {
    
    public static final String FIELD_ID = "linkId";
    public static final String FIELD_SPEED = "linkSpeed";
    public static final String FIELD_TRAVELTIME = "linkTravelTime";
    public static final String FIELD_STATUS = "linkStatus";
    public static final String FIELD_DATE = "linkTimeStamp";
    public static final String FIELD_POLYLINE = "linkPolyline";
    public static final String FIELD_NAME = "linkName";
    public static final double JOIN_DISTANCE = 0.001;
    public static final String NY_LINK_CAMS_URL = "http://dotsignals.org/nyc-links-cams/TrafficSpeed.php";
    public static final int TIME_BETWEEN_UPDATES = 30000;
    private List<ParsedNode> pnodes;
    private Map<Integer, ParsedNode> hashnodes;
    private Map<Integer, Integer> nodeDistances;
    
    public static void main(String[] args) {
        if (args == null || args.length < 2 || args.length > 3) {
            printUsage();
            return;
        }
        
        NYTrafficProvider parser = new NYTrafficProvider();
        if (!parser.initialize(args.length == 3 ? args[2] : null)) {
            // Abort program in case of error
            return;
        }
        parser.generateOutput();
        
        switch(args[0]) {
            case "-output":
                parser.printCoordinatesForSolution(args[1]);
                return;
            case "-distances":
                parser.generateDistancesFile(args[1]);
                return;
            default:
                parser.generateOutputFile(args[0]);
        }
        
        int update = 0;
        /*while (true) {
            Thread.sleep(TIME_BETWEEN_UPDATES);
            System.out.println("Doing update!");
            int updates = parser.update();
            System.out.println(updates + " nodes updated!");
            parser.generateUpdateFile(args[1], update);
            update++;
        }*/
    }
    
    private boolean initialize(String distanceFile) {
        try {
            if (distanceFile != null && !loadDistancesFile(distanceFile)) {
                // Abort the program in case of error
                return false;
            }

            readAndParseNodes();
            //addManualEdges();
            generateGraph();
            int removed;
            do {
                removed = removeIsolatedNodes();
            } while (removed != 0);
            generatePositionGraph();
            return true;
        } catch (Exception ex) {
            ex.printStackTrace();
            return false;
        }
    }
    
    private int update() {
        try {
            /*URL linkquery = new URL(NY_LINK_CAMS_URL);
            BufferedReader in = new BufferedReader(
                new InputStreamReader(linkquery.openStream()));*/
            
            File fXmlFile = new File(NY_LINK_CAMS_URL);
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            Document doc = dBuilder.parse(fXmlFile);
            
            int updates = 0;
            /*String inputLine = in.readLine(); // Ignore first line (headers)
            while ((inputLine = in.readLine()) != null) {
                if (inputLine.charAt(inputLine.length()-1) != '\"') {
                    inputLine += in.readLine();
                }
                inputLine = inputLine.replace("\"", "");
                String[] fields = inputLine.split("\t");
                
                try {
                    int id = Integer.parseInt(fields[FIELD_ID]);
                    if (hashnodes.containsKey(id)) {
                        ParsedNode node = hashnodes.get(id);
                        int newtime = Integer.parseInt(fields[FIELD_TRAVELTIME]);
                        boolean newstatus = fields[FIELD_STATUS].equals("1");
                        if (node.isStatus() != newstatus) {
                            if (node.isStatus()) {
                                node.setDistance(Integer.MAX_VALUE);
                                node.setTravelTime(Integer.MAX_VALUE);
                            } else {
                                node.setDistance(nodeDistances.get(id));
                                node.setTravelTime(newtime);
                            }
                            node.setDistanceUpdated(true);
                            node.setCostUpdated(true);
                            node.setStatus(newstatus);
                        }
                        
                        if (node.getTravelTime() != newtime) {
                            node.setTravelTime(newtime);
                            node.setCostUpdated(true);
                        }
                        
                        if (node.isCostUpdated() || node.isDistanceUpdated()) {
                            System.out.println("Updated " + node.getId() + ": " + node.getDistance() + "," + newtime);
                            updates++;
                        }
                    }
                }
                catch (Exception ex) {
                    System.err.println("Ignored line " + fields[0] + " cause an error in parsing.");
                }
            }
            in.close();*/
            return updates;
        } catch (Exception ex) {
            ex.printStackTrace();
            return -1;
        }
    }
    
    private void addManualEdges() {
        int[][] addnodes = new int[][]{ {450, 338},
            {385, 417},
            {298, 126},
            {129, 168}};
        
        for (int[] node : addnodes) {
            hashnodes.get(node[0]).addNode(hashnodes.get(node[1]));
            hashnodes.get(node[1]).addNode(hashnodes.get(node[0]));
        }
    }
    
    private void readAndParseNodes() {
        pnodes = new ArrayList<>();
        hashnodes = new HashMap<>();
        Document doc = null;
        
        try {
            URL url = new URL(NY_LINK_CAMS_URL);
            URLConnection connection = url.openConnection();
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            doc = dBuilder.parse(connection.getInputStream());
        } catch (Exception ex) {
            System.err.println("Error reading the XML File.");
            ex.printStackTrace();
            return;
        }
        
        if (doc == null) {
            System.err.println("Error reading the XML File.");
            return;
        }

        doc.getDocumentElement().normalize();

        NodeList nodeList = doc.getElementsByTagName("TrafficSpeedData");

        for (int i = 0; i < nodeList.getLength(); i++) {
            Element eElement = (Element)nodeList.item(i);

            List<Coord> coordinates = GoogleDecode.decode(eElement.getAttribute(FIELD_POLYLINE));
            if (coordinates != null) {
                
                ParsedNode pnode = new ParsedNode(
                    Integer.parseInt(eElement.getAttribute(FIELD_ID)),
                    Double.parseDouble(eElement.getAttribute(FIELD_SPEED)),
                    Integer.parseInt(eElement.getAttribute(FIELD_TRAVELTIME)),
                    eElement.getAttribute(FIELD_STATUS).equals("1"),
                    eElement.getAttribute(FIELD_POLYLINE),
                    eElement.getAttribute(FIELD_NAME),
                    GoogleDecode.decode(eElement.getAttribute(FIELD_POLYLINE)));

                pnode.setDistance(getDistanceForNode(pnode));

                pnodes.add(pnode);
                hashnodes.put(pnode.getId(), pnode);
                System.out.println("Added node " + pnode);
            } else {
                System.err.println("Ignored node " + eElement.getNodeName() + " cause an error in parsing.");
            }
        }
        System.out.println(pnodes.size());
        System.out.println(hashnodes.size());
    }
    
    private void generateGraph() {
        for (ParsedNode pnode : pnodes) {
            for (ParsedNode p : pnodes) {
                if (!pnode.getId().equals(p.getId())) {
                    
                    double dist1 = pnode.getCoords().get(pnode.getCoords().size()-1).distance(p.getCoords().get(0));
                    double dist2 = pnode.getCoords().get(0).distance(p.getCoords().get(p.getCoords().size()-1));
                    
                    if (dist1 < JOIN_DISTANCE || dist2 < JOIN_DISTANCE) {
                        pnode.addNode(p);
                        p.addNode(pnode);
                    }
                }
            }
        }
    }
    
    private int removeIsolatedNodes() {
        Iterator<ParsedNode> itr = pnodes.iterator();
        int count = 0;
        while (itr.hasNext()) {
            ParsedNode node = itr.next();
            if (node.getNodes().size() < 2) {
                removeEdgesFor(node);
                count++;
                itr.remove();
            }
        }
        return count;
    }
    
    private void removeEdgesFor(ParsedNode node) {
        for (ParsedNode pnode : pnodes) {
            pnode.getNodes().remove(node);
        }
    }
    
    private void generatePositionGraph() {
        int i = 0;
        for (ParsedNode node : pnodes) {
            node.setPosition(i);
            i++;
        }
    }
    
    private void generateOutput() {
        // First line is the total number of cities
        System.out.println(pnodes.size());
        for (ParsedNode node : pnodes) {
            int nodePosition = node.getPosition();
            for (ParsedNode edge : node.getNodes()) {
                int edgePosition = edge.getPosition();
                System.out.println(nodePosition + " " + edgePosition + " " + node.getDistance() + " " + node.getSpeed() + " " + node.getId());
            }
        }
    }
    
    private int getDistanceForNode(ParsedNode pnode) {
        // If distances are not cached, call the Google Service
        if (nodeDistances == null) {
            try {
                Integer dist1 = GoogleDecode.getDistance(pnode.getCoords().get(0), pnode.getCoords().get(pnode.getCoords().size()-1));
                Integer dist2 = GoogleDecode.getDistance(pnode.getCoords().get(pnode.getCoords().size()-1), pnode.getCoords().get(0));
                return Math.min(dist1, dist2);
            } catch (Exception ex) {
                Logger.getLogger(NYTrafficProvider.class.getName()).log(Level.SEVERE, "Error getting Google Distance for node " + pnode.getId(), ex);
                return 0;
            }
        } else {
            if (nodeDistances.containsKey(pnode.getId())) {
                return nodeDistances.get(pnode.getId());
            } else {
                Logger.getLogger(NYTrafficProvider.class.getName()).log(Level.SEVERE, "Error loading cached distance for node {0}", pnode.getId());
                return 0;
            }
        }
    }
    
    private boolean loadDistancesFile(String path) {
        nodeDistances = new HashMap<>();
        try (Scanner scan = new Scanner(new File(path))) {
            int nodes = scan.nextInt();
            for (int node = 0; node < nodes; node++) {
                int id = scan.nextInt();
                int distance = scan.nextInt();
                nodeDistances.put(id, distance);
            }
            return true;
        } catch (Exception e) {
            Logger.getLogger(NYTrafficProvider.class.getName()).log(Level.SEVERE, "Error loading cached distances for file {0}", path);
            e.printStackTrace();
            return false;
        }
    }
    
    private void generateDistancesFile(String path) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(path))) {
            // First line is the total number of nodes
            writer.write(pnodes.size() + "\n");
            for (ParsedNode node : pnodes) {
                writer.write(node.getId() + " " + node.getDistance() + "\n");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private void generateOutputFile(String path) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(path))) {
            // First line is the total number of cities
            writer.write(pnodes.size() + "\n");
            for (ParsedNode node : pnodes) {
                int nodePosition = node.getPosition();
                for (ParsedNode edge : node.getNodes()) {
                    int edgePosition = edge.getPosition();
                    writer.write(nodePosition + " " + edgePosition + " " + node.getDistance() + " " + node.getTravelTime()+ " " + node.getId() + "\n");
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private void generateUpdateFile(String path, int update) {
        path = path.replace("?", String.valueOf(update));
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(path))) {
            for (ParsedNode node : pnodes) {
                if (node.isCostUpdated() || node.isDistanceUpdated()) {
                    int nodePosition = node.getPosition();
                    for (ParsedNode edge : node.getNodes()) {
                        int edgePosition = edge.getPosition();
                        if (node.isCostUpdated()) {
                            writer.write("c " + nodePosition + " " + edgePosition + " " + node.getTravelTime() + "\n");
                            node.setCostUpdated(false);
                        }
                        if (node.isDistanceUpdated()) {
                            writer.write("d " + nodePosition + " " + edgePosition + " " + node.getDistance() + "\n");
                            node.setDistanceUpdated(false);
                        }
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private void printCoordinatesForSolution(String solution) {
        System.out.println("Coordinates for solution: ");
        System.out.println(solution);
        for (String sol : solution.split(" ")) {
            int id = Integer.parseInt(sol);
            System.out.println(pnodes.get(id).getCoords().get(0).getX() + "," + pnodes.get(id).getCoords().get(0).getY());
        }
    }
    
    private static void printUsage() {
        System.out.println("Usages:");
        System.out.println("");
        System.out.println(" * NYTrafficProvider <initial output file> <updates output folder> <[distances file]>");
        System.out.println("");
        System.out.println("    This is the main usage of the class. It will parse the URL with information about");
        System.out.println("    the New York Traffic Cameras, generating an initial file to execute the problem.");
        System.out.println("    In addition, every 30 seconds a new file will be generated in the updates path,");
        System.out.println("    containing all the speed and time updates since the last iteration:");
        System.out.println("");
        System.out.println("    - <initial output file>: The file to write the initial problem, containing ");
        System.out.println("      all the initial information to execute the optimization.");
        System.out.println("    - <updates output folder>: The path to generate the updates, where every 30 seconds ");
        System.out.println("      a new file will be written with all the updates received by the traffic cameras.");
        System.out.println("    - <[distances file]>: An optional argument to load the distances between nodes and");
        System.out.println("        avoid doing requests to the Google Service, which has a limited quota.");
        System.out.println("");
        System.out.println(" * NYTrafficProvider -distances <distances output file>");
        System.out.println("");
        System.out.println("    This is an optional feature to avoid reaching the limit of the Google Services quota.");
        System.out.println("    As the distances never change, it is possible to preload all of them in a file and");
        System.out.println("    pass the generated file to the problem generator.");
        System.out.println("    To load the node distances the program will use the Google Distance Service. You need a ");
        System.out.println("    Google API Key to be able to use the service.");
        System.out.println("");
        System.out.println("    - <distances output file>: The file to write the distances.");
        System.out.println("");
        System.out.println(" * NYTrafficProvider -output <solution string>");
        System.out.println("");
        System.out.println("    The last usage is just to generate a file containing all the coordinates of a solution");
        System.out.println("    given by the optimization algorithm. So the solution could be easily shown in a map");
        System.out.println("    or a chart.");
        System.out.println("");
        System.out.println("    - <solution string>: The solution string generated by the optimization algorithm. It ");
        System.out.println("      contains a list of the nodes forming the solution.");
        System.out.println("");
    }
}



